<h3>Оглавление</h3>
<a href="#one">1. Теория</a><br>
<a href="#n1">&nbsp;1.1. Каковы основные принципы ООП?</a><br>
<a href="#n2">&nbsp;1.2. В чем отличия InnoDB от MyISAM?</a><br>
<a href="#n3">&nbsp;1.3. Что такое lambda-функция и замыкание и каков синтаксис при их использовании в PHP?</a><br>
<a href="#n4">&nbsp;1.4. Что означает запись $a =& $b?</a><br>
<a href="#n5">&nbsp;1.5. Что такое TDD?</a><br>
<a href="#n6">&nbsp;1.6. В чем отличие типа DECIMAL от FLOAT в mysql и в каких случаях нужно использовать тот или иной тип данных? </a><br>
<a href="#n7">&nbsp;1.7. Что такое Singleton и в каких случаях его следует применять? </a><br>
<a href="#n8">&nbsp;1.8. Чем отличается абстрактный класс от интерфейса? </a><br>
<a href="#n9">&nbsp;1.9. Что означает запись $a = 'ololo'; $b = $$a;  </a><br>
<a href="#n10">&nbsp;1.10. Что такое adjacency tree? Какие есть альтернативы?   </a><br>
<a href="#n11">&nbsp;1.11. Для чего нужны индексы в базе данных и как они работают? </a><br>
<a href="#n12">&nbsp;1.12. Что означает запись $a = $b ?: $c; ? </a><br>
<a href="#n13">&nbsp;1.13. Какие виды атак возможны при заполнении формы для публикации в блог?  </a><br>

<h3 id="one">Четко дать определения и ответы на вопросы </h3>

<p id="n1">Каковы основные принципы ООП? </p>

```php
Объектно-ориентированное программирование (ООП) — методология программирования,
основанная на представлении программы в виде совокупности объектов, каждый из которых
является экземпляром определенного класса, а классы образуют иерархию наследования.

SOLID (single responsibility, open-closed, Liskov substitution,
interface segregation и dependency inversion) - пять основных принципов
объектно-ориентированного программирования и проектирования. 

Эти принципы, когда применяются вместе, предназначены для повышения вероятности того,
что программист создаст систему, которую будет легко поддерживать и расширять в течение
долгого времени. Принципы SOLID - это руководства, которые могут применяться во время
работы над программным обеспечением для удаления «кода с запашком» предписывая программисту
выполнять рефакторинг исходного кода, пока тот не станет разборчиво написанным и расширяемым. 

1. S (Single responsibility principle) -
Принцип единственной обязанности 

класс должен иметь только одну ответственность
(то есть повлиять на спецификацию класса должно быть способно
только одно потенциальное изменение в спецификации ПО)

2. O (Open/closed principle)  
Принцип открытости/закрытости 

«программные сущности должны быть открыты для расширения, но закрыты для модификации»

3. L Liskov substitution principle)
Принцип подстановки Барбары Лисков

объекты в программе должны быть заменяемыми на экземпляры
их подтипов без изменения правильности выполнения программы

4. I (Interface segregation principle)
Принцип разделения интерфейса 

«много интерфейсов, специально предназначенных для клиентов,
лучше, чем один интерфейс общего назначения.»

5. D (Dependency inversion principle)
Принцип инверсии зависимостей 
Зависимость на Абстракциях
Нет зависимости на что-то конкретное

```

<p id="n2"> В чем отличия InnoDB от MyISAM? </p>

```php
InnoDB — одна из выбираемых подсистем низкого уровня в СУБД MySQL,
входит во все стандартные сборки для различных операционных систем.
Основным отличием InnoDB от других подсистем низкого уровня MySQL
является наличие механизма транзакций и внешних ключей.

СУБД InnoDB была разработана Хейкки Туури из компании Innobase — финского
производителя программного обеспечения, специализирующегося на технологии
реляционных баз данных. InnoDB представляет собой результат исследований,
проводимых Хейкки в университете Хельсинки.

В отличие от таблиц MyISAM, где для каждой таблицы создается один файл данных,
данные InnoDB в настройках по умолчанию хранятся в больших совместно используемых
файлах (изменить это можно с помощью настроек опции innodb_file_per_table),
что позволяет использовать постраничный кэш страниц базы данных. Формат данных
InnoDB обеспечивает надежное хранение данных за счет транзакционности и блокировки
данных на уровне строки.

MyISAM поддерживает сжатие таблиц в отличии от InnoDB.
MyISAM имеет встроенные полнотекстный поиск в отличии от InnoDB.
InnoDB поддерживает транзакции в отличии от MyISAM.
InnoDB поддерживает блокировки уровня строки (MyISAM - только уровня таблицы).
InnoDB поддерживает ограничения внешних ключей (MyISAM - нет).
InnoDB более надежна при больших объемах данных.
InnoDB в теории немного быстрее.
```


<p id="n3"> Что такое lambda-функция и замыкание и каков синтаксис при их использовании в PHP? </p>

```php
Аспекты функционального программирования:
1. Чистые функции -  функция никаким образом не меняет значения переменных,
которые находятся за её пределами и не осуществляет действия по вводу/выводу
данных в файл, базу данных и т.д

2. Функции высших порядков - могут принимать в качестве аргументов и возвращать другие функции

3. Лямбда функция - ничто иное, как функции без названия, работа с подобными функциями
осуществляется через переменную, которой данная функция была присвоена.

4. Замыкания -  необходимость иметь доступ к какой-то переменной, 
которая находится за пределами анонимной функции, но не является входящим параметром

5. Каррирование и частичное применение - это функции содержащие другие функции,
которые работают с набором аргументов родителя

Во многих мини-фреймворках роутинг сейчас работает на анонимных функциях.
App::router(‘GET /users’, function() use($app){
    $app->response->write(‘Hello, World!’);
});

Рекурсивное определение замыкания
$factorial = function( $n ) use ( &$factorial ) {
    if( $n == 1 ) return 1;
    return $factorial( $n - 1 ) * $n;
};

print $factorial( 5 );
```

<p id="n4"> Что означает запись $a =& $b </p>

```php
Такая операция (=&) называется передачей по ссылке,
в некоторых языках она бывает неявно

<?php

$a=10;
$b = &$a; // теперь $b — то же самое, что и $a
$b=0; // на самом деле $a=0
echo "b=$b, a=$a"; // Выводит: "b=0, a=0"

?>

Вы можете передавать переменные в функцию по ссылке, 
и функция сможет изменять свои аргументы. Синтаксис таков:

<?php
function foo(&$var) 

// Любое другое выражение не должно передаваться по ссылке,
// так как результат не определён

{
    $var++;
}

$a=5;
foo($a);
// $a здесь равно 6
?>


Вы не должны думать о производительности на этом этапе. Вопросы производительности
нужно решать при возникновении проблем. Подумайте лучше о смысле параметров.

Передача параметра по ссылке означает, что параметр может быт изменён вызываемой процедурой. 
Это то, чего вы хотите? Если вызываемая процедура не должна ни в коем случае менять значение
передаваемой переменной, не нужно и передавать её по ссылке. Также подумайте о том, что в
качестве ссылочного параметра вы не сможете передать выражение типа $n + 1.

Передача по ссылке означает "параметр имеет право быть изменён вызываемой функцией". 
Тот, кто будет читать код после вас, вынужден будет предполагать, что такие изменения возможны 
или ему придётся привыкать к вашему нестандартному стилю программирования.

Вы должны думать о читаемости и понимаемости кода, а не искать мизерный выигрыш. 
Потому что мизерный выигрыш обернётся проблемами при поддержке и масштабировании проекта.

Наверняка передача по ссылке или по значению как-то отражается на времени загрузки страницы, 
но это всё зависит от версии. Например, в некоторых случаях в C++ раньше рекомендовалось 
передавать параметры по ссылке, а сейчас -- по значению.



```

<p id="n5"> Что такое TDD? </p>

```php
Разработка через тестирование (англ. test-driven development, TDD) — является передовой
техникой разработки программного обеспечения, основывающеюся на повторении кратких циклов
разработки: изначально пишется тест, который покрывает желаемое изменение, а далее пишется
сам код, позволяющий пройти данный тест, и в конце проводится рефакторинг нового кода к
соответствующим стандартам.

Иными словами, разработка через тестирование это набор юнит-тестов, которые можно запустить
на любом этапе, чтобы убедиться, что программное обеспечение по-прежнему работает.

Тест — это процедура, которая позволяет либо подтвердить, либо опровергнуть 
работоспособность кода. Когда программист проверяет работоспособность разработанного им кода,
он выполняет тестирование вручную.

TDD не только предполагает проверку корректности, но и влияет на дизайн программы.
Опираясь на тесты, разработчики могут быстрее представить, какая функциональность
необходима пользователю. Таким образом, детали интерфейса появляются задолго
до окончательной реализации решения.

Разумеется, к тестам применяются те же требования стандартов кодирования, что и к основному коду.
```

<p id="n6"> В чем отличие типа DECIMAL от FLOAT в mysql и в каких случаях нужно использовать тот или иной тип данных? </p>

```php
FLOAT занимает один байт и представляет числа от -3.402823466E+38 до -1.175494351E-38,
DOUBLE занимает два байта и представляет числа от -1.7976931348623157E+308 
to -2.2250738585072014E-308 (т.е. диапазон почти на 10 порядков больше). Но это обычные
приближенные числа, т.е. при вычислениях будет накапливаться ошибка вычисления, так как числа
представлены моделью. Если нужно, чтобы дробное число было точным, то его хранят не в виде модели,
а строке DECIMAL - операции с такими числами проходят медленнее, зато ничего не теряется и 
не накапливается лишнего, что например, при работе с деньгами очень важно - пусть хоть пол часа
вычисляется, но зато точно.

MySQL поддерживает все числовые типы данных языка SQL92 по стандартам ANSI/ISO. Они включают
в себя типы точных числовых данных (NUMERIC, DECIMAL, INTEGER и SMALLINT) и типы приближенных
числовых данных (FLOAT, REAL и DOUBLE PRECISION). Ключевое слово INT является синонимом для INTEGER,
а ключевое слово DEC - синонимом для DECIMAL.

Типы данных NUMERIC и DECIMAL реализованы в MySQL как один и тот же тип - это разрешается
стандартом SQL92. Они используются для величин, для которых важно сохранить повышенную точность,
например для денежных данных. Требуемая точность данных и масштаб могут задаваться (и обычно задаются)
при объявлении столбца данных одного из этих типов, например:

Тип FLOAT обычно используется для представления приблизительных числовых типов данных. 
Стандарт ANSI/ISO SQL92 допускает факультативное указание точности (но не интервала порядка числа)
в битах в круглых скобках, следующих за ключевым словом FLOAT. Реализация MySQL также поддерживает
это факультативное указание точности. При этом если ключевое слово FLOAT в обозначении типа столбца
используется без указания точности, MySQL выделяет 4 байта для хранения величин в этом столбце. 
Возможно также иное обозначение, с двумя числами в круглых скобках за ключевым словом FLOAT. 
В этом варианте первое число по-прежнему определяет требования к хранению величины в байтах, 
а второе число указывает количество разрядов после десятичной запятой, которые будут храниться и 
показываться (как для типов DECIMAL и NUMERIC).
```

<p id="n7"> Что такое Singleton и в каких случаях его следует применять? </p>

```php
Singleton - один из порождающих паттернов, впервые описанный «бандой четырех» (GoF).
Гарантирует, что у класса есть только один экземпляр, и предоставляет к нему
глобальную точку доступа. 

Singleton – один из самых простых шаблонов для понимания.
Основное назначение – гарантировать существование только одно экземпляра класса.
Причиной обычно является следующее: требуется только один объект исходного класса и
Вам необходимо, что бы объект был доступен в любом месте приложения, т.е. глобальный доступ. 

Шаблоны проектирования:
1. Factory (Фабрика)
2. Singleton (Одиночка)
3. Front Controller (Фронт-контролер)
4. MVC (Модель-представление-контроллер)
5. HMVC
6. MVVM

Singleton
При создании веб приложения, часто требуется концептуально и архитектурно
предоставить доступ только к одному экземпляру определённого класса. 
Шаблон Одиночка позволяет это сделать.

<?php
class Singleton
{
    /**
     * @var Singleton The reference to *Singleton* instance of this class
     */
    protected static $instance;
    
    /**
     * Returns the *Singleton* instance of this class.
     *
     * @return Singleton The *Singleton* instance.
     */


    public static function getInstance()
    {
        if (null === static::$instance) {
            static::$instance = new static();
        }

        return static::$instance;
    }

    /**
     * Protected constructor to prevent creating a new instance of the
     * *Singleton* via the `new` operator from outside of this class.
     */

    protected function __construct()
    {
    }

    /**
     * Private clone method to prevent cloning of the instance of the
     * *Singleton* instance.
     *
     * @return void
     */

    private function __clone()
    {
    }

    /**
     * Private unserialize method to prevent unserializing of the *Singleton*
     * instance.
     *
     * @return void
     */

    private function __wakeup()
    {
    }
}

class SingletonChild extends Singleton
{
}

$obj = Singleton::getInstance();
var_dump($obj === Singleton::getInstance());             // bool(true)

$anotherObj = SingletonChild::getInstance();
var_dump($anotherObj === Singleton::getInstance());      // bool(false)

var_dump($anotherObj === SingletonChild::getInstance()); // bool(true)

?>

Этот код реализует данный шаблон, используя статические переменные и
статический метод getInstance(). Обратите внимание на следующее:

1) Конструктор __construct сделан защищённым (protected), чтобы запретить создание 
нового объекта с помощью оператора new.

2) Магический метод __clone определён как частный (private), чтобы предотвратить
клонирование экземпляра класса с помощью clone.

3) Магический метод __wakeup определён как частный (private), чтобы предотвратить
десериализации экземпляра класса через глобальную функцию unserialize().

4) Новый экземпляр создаётся с помощью позднего статического связывания в статическом
методе getInstance() с ключевым словом static

Шаблон Одиночка полезен тогда, когда нужно быть уверенным, что экземпляр класса только один
во жизненном цикле запроса для веб приложения. Обычно это происходит, когда имеется глобальный
объект (например Configuration класс) или общий ресурс (например очередь событий).

Вы должны быть осторожными, используя этот шаблон, поскольку по своей природе он вводит
глобальное утверждение экземпляра в приложении, понижая тем самым тестируемость. 
В большинстве случаев внедрение зависимостей могут (должны) использоваться вместо
Singleton класса. Используя внедрение зависимости, означает, что мы не вводим ненужных
соединений в дизайн наших приложения, а объект, используя общий или глобальный ресурс, 
не требует знания конкретного класса.
```

<p id="n8"> Чем отличается абстрактный класс от интерфейса? </p> 

```php
Абстрактный класс - это класс, у которого не реализован один или больше методов
(некоторые языки требуют такие методы помечать специальными ключевыми словами).

Интерфейс - это абстрактный класс, у которого все методы не реализованы,
все публичные и нет переменных класса.


<?php

interface I { 
    public function F(); 
    public function say(); 
} 

abstract class A implements I { 
    function say() { 
        echo 'Hello'; 
    } 
    // function F() - не реализована 
} 

?>

Абстрактный класс наследуется (etxends), а интерфейс реализуется (implements).
Вот и возникает разница между ними, что наследовать мы можем только один класс,
а реализовать сколько угодно. При реализации интерфейса, необходимо реализовать
все его методы, иначе будет вызвана ошибка Fatal error, однако этого можно
избежать, присвоив ключевое слово abstract для класса.

Интерфейс нужен обычно, когда описывается только интерфейс (тавтология).
Например, один класс хочет дать другому возможность доступа к некоторым своим методам,
но не хочет себя "раскрывать". Поэтому он просто реализует интерфейс.

Абстрактный класс нужен, когда нужно семейство классов, у которых есть много общего.
Конечно, можно применить и интерфейс, но тогда нужно будет писать много идентичного кода.

В некоторых языках (С++) специального ключевого слова для обозначения интерфейсов нет.
Можно считать, что любой интерфейс - это уже абстрактный класс, но не наоборот.
```

<p id="n9"> Что означает запись $a = 'ololo'; $b = $$a; </p>
```php

<?php

$ololo = 1;

$a = 'ololo'; 
$b = $$a;

print($b); // 1

?>

Даёт возможность получить значение в качестве названия переменной
Такая необходимость нужна, когда есть причина на лету собирать
имя переменной

Такое будет работать и для функций

<?php
function get_animal() {
 return 'dog';
}
function check_dog() {
  return 'dog ok';
}
function check_cat() {
 return 'cat ok';
}
 
$check_func = 'check_' . get_animal();
 
echo $check_func(); // dog ok

?>
```

<p id="n10"> Что такое adjacency tree? Какие есть альтернативы? </p>

```php
Список смежности (adjacency tree) — один из способов 
представления графа в виде коллекции списков вершин. 
Каждой вершине графасоответствует список, состоящий
из "соседей" этой вершины.

Пример функции, которая выводит список смежности
в виде вложенных ul/li:

<?php

/**
 * Возвращает html код дерева
 * @param  array    $tree - массив в формате 
 * @param  integer  $pid - id родителя
 */
function get_tree($tree, $pid)
{
    $html = '';
 
    foreach ($tree as $row)
    {
        if ($row['pid'] == $pid)
        {
            $html .= '<li>' . "\n";
            $html .= '    ' . $row['name'] . "\n";
            $html .= '    ' . get_tree($tree, $row['id']);
            $html .= '</li>' . "\n";
        }
    }
 
    return $html ? '<ul>' . $html . '</ul>' . "\n" : '';
}


$tree = array(
    array('name' => 'Уровень 1',     'id' => 1,  'pid' => 0),
    array('name' => 'Уровень 1.1',   'id' => 2,  'pid' => 1),
    array('name' => 'Уровень 1.2',   'id' => 3,  'pid' => 1),
    array('name' => 'Уровень 1.3',   'id' => 4,  'pid' => 1),
    array('name' => 'Уровень 2',     'id' => 5,  'pid' => 0),
    array('name' => 'Уровень 2.1',   'id' => 6,  'pid' => 5),
    array('name' => 'Уровень 2.2',   'id' => 7,  'pid' => 5),
    array('name' => 'Уровень 3',     'id' => 8,  'pid' => 0),
    array('name' => 'Уровень 3.1',   'id' => 9,  'pid' => 8),
    array('name' => 'Уровень 3.1.1', 'id' => 10, 'pid' => 9),
    array('name' => 'Уровень 3.1.2', 'id' => 11, 'pid' => 9),
);
 
echo get_tree($tree, 0);

?>

```

<p id="n11"> Для чего нужны индексы в базе данных и как они работают? </p>

```php
Индекс (англ. index) — объект базы данных, создаваемый с целью повышения производительности
поиска данных. Таблицы в базе данных могут иметь большое количество строк, которые хранятся 
в произвольном порядке, и их поиск по заданному критерию путём последовательного просмотра 
таблицы строка за строкой может занимать много времени. Индекс формируется из значений одного 
или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и, таким образом, 
позволяет искать строки, удовлетворяющие критерию поиска. Ускорение работы с использованием 
индексов достигается в первую очередь за счёт того, что индекс имеет структуру, 
оптимизированную под поиск — например, сбалансированного дерева.

Некоторые СУБД расширяют возможности индексов введением возможности создания индексов по 
столбцам представлений или индексов по выражениям. Например, индекс может быть создан 
по выражению upper(last_name) и соответственно будет хранить ссылки, ключом к которым будет 
значение поля last_name в верхнем регистре. Кроме того, индексы могут быть объявлены как 
уникальные и как не уникальные. Уникальный индекс реализует ограничение целостности на таблице, 
исключая возможность вставки повторяющихся значений.

Существует два типа индексов: кластерные и некластерные. При наличии кластерного индекса 
строки таблицы упорядочены по значению ключа этого индекса. Если в таблице нет кластерного 
индекса, таблица называется кучей[3]. Некластерный индекс, созданный для такой таблицы, 
содержит только указатели на записи таблицы. Кластерный индекс может быть только одним для 
каждой таблицы, но каждая таблица может иметь несколько различных некластерных индексов, 
каждый из которых определяет свой собственный порядок следования записей.

Индексы могут быть реализованы различными структурами. Наиболее частоупотребимы 
B*-деревья, B+-деревья, B-деревья и хеши.

Для оптимальной производительности запросов индексы обычно создаются на тех столбцах таблицы, 
которые часто используются в запросах. Для одной таблицы может быть создано несколько индексов. 
Однако увеличение числа индексов замедляет операции добавления, обновления, удаления строк таблицы, 
поскольку при этом приходится обновлять сами индексы. Кроме того, индексы занимают дополнительный 
объем памяти, поэтому перед созданием индекса следует убедиться, что планируемый выигрыш в 
производительности запросов превысит дополнительную затрату ресурсов компьютера на 
сопровождение индекса.


```

<p id="n12"> Что означает запись $a = $b ?: $c; </p>

```php
Тернарный оператор работает почти также как и оператор if, но при использовании тернарного оператора, 
мы вместо ключевых слов пишем ? и :. 

<?php

$c = 5;
$b = 0;

$a = $b ?: $c; // 5

print($a); 

$b = 10;
$a = $b ?: $c; // 10

print(" {$a}"); 

?>

В результате мы увидим строку - "5 10"

Еще один пример:

<?php

$speed = 55;

echo ($speed <= 60) ? "Скорость в пределах нормы" : "Превышение скорости !"; 
?>

В результате мы увидим строку - "Скорость в пределах нормы"


```

<p id="n13"> Какие виды атак возможны при заполнении формы для публикации в блог? </p>

```php
Все компании, имеющие сайт в интернете, делятся на три типа:

1. Те, чей сайт уже сломали
2. Те, чей сайт еще не ломали
3. Те, кто знаком с основными векторами атак и защитил приложения

Виды атак:

1. Инъекции — Injections

Такой вид атаки называется инъекция, в данном случае самый распространённый — SQL-инъекция.
Это опаснейшая уязвимость, позволяющая злоумышленнику получить доступ к базе данных и 
возможность читать/изменять/удалять информацию, которая для него не предназначена. 

Например, изменить вместе с именем и фамилией баланс своего счета, посмотреть баланс 
чужого счета, или же, похитить конфиденциальные личные данные.

Эта уязвимость является следствием недостаточной проверки данных, поступающих от пользователя. 
Это позволяет злоумышленнику «подсунуть», например, в веб-формы, специально подготовленные запросы, 
которые «обманут» приложение и позволят прочитать или записать нелегитимные данные. 

2. Недочеты системы аутентификации и хранения сессий

Для того, чтобы отличать одного пользователя от другого, web-приложение использует так называемые 
сессионные куки. После того, как Вы ввели логин и пароль и приложение вас авторизовало, 
в хранилище браузера сохраняется специальный идентификатор, который браузер в дальнейшем предъявляет 
серверу при каждом запросе страницы вашего web-приложения. Именно так web-приложение понимает, что 
Вы это именно Вы. 

В случае, если ваш идентификатор украдет злоумышленник, а в системе не были реализованы проверки, 
скажем IP-адреса сессии, или проверки наличия более одного соединения в одной сессии, злоумышленник 
сможет получить доступ в систему с правами вашего аккаунта. А если это интернет-банк или кабинет 
платежной системы, о последствиях такого несанкционированного доступа Вы можете легко догадаться сами.

3. Межсайтовый скриптинг – XSS (Cross Site Scripting)

Межсайтовый скриптинг – еще одна ошибка валидации пользовательских данных, которая позволяет передать 
JavaScript код на исполнение в браузер пользователя. Атаки такого рода часто также называют 
HTML-инъекциями, ведь механизм их внедрения очень схож с SQL-инъекциями, но в отличие от последних,
внедряемый код исполняется в браузере пользователя. Чем это чревато? 

Во-первых, злоумышленник может украсть вашу сессионную cookie, последствия чего были описаны во 
втором пункте. Нужно отметить, что далеко не все серверы приложений уязвимы к данному типу атак.

Во-вторых, могут быть украдены данные, вводимые в формы на зараженной странице. А это могут быть 
конфиденциальные персональные данные, или, что еще хуже, данные кредитной карты вместе с CVC-кодом. 

В третьих, через JavaScript можно изменять данные, расположенные на странице, например, там могут 
быть реквизиты для банковского перевода, которые злоумышленник с удовольствием подделает 
и заменит подставными.

4.  Небезопасные прямые ссылки на объекты (Insecure Direct Object References)

Данный вид уязвимости является также следствием недостаточной проверки пользовательских данных.
Суть ее заключается в том, что при выводе каких-либо конфиденциальных данных, например личных
сообщений или учетных карточек клиентов, для доступа к объекту используется идентификатор, 
который передается в открытом виде в адресной строке браузера, И не реализована проверка прав 
доступа к объектам. Например, есть страница, которая отображает личное сообщение и она имеет 
адрес вида:

mysite.ru/read_message.jsp?id=123654

Перебирая число после "id=" можно будет читать чужие личные сообщения. Эксплуатация данной 
уязвимости очень проста и не требует вообще никаких специальных навыков – достаточно лишь
перебирать число в адресной строке браузера и наслаждаться результатом. Как ни парадоксально, 
но этой детской болезни, порой были подвержены достаточно крупные европейские платежные системы.

5. Небезопасная конфигурация (Security Misconfiguration)

При правильной настройке сервера и включенной опции cookie_httponly, получить сессионную cookie
через JavaScript невозможно, но зачастую эта простая и важная настройка отсутствовала в таких
критично важных местах, как личные кабинеты платежных систем.

Еще один пример детской уязвимости – использование настроек по-умолчанию в серверах баз данных,
таких как Redis, Memcached и других – закрытая служба может быть доступна на публичном IP-адресе
сервера, и/или использовались пароли, установленные производителем по-умолчанию. Это позволяет
злоумышленнику запросто читать и изменять данные, в числе которых, нередко бывают и сессионные
cookies (чем это чревато – мы уже знаем) и выводимые пользователям в браузер данные (что позволяет
еще и XSS-атаку применить).

Кроме того, программное обеспечение должно быть в актуальном состоянии: уязвимости находят каждый
день в самых различных программных компонентах – операционной системе, web-серверах, серверах баз
данных, почтовых серверах и т.д. И даже если ваше приложение правильно написано и тщательно проверяет
все входящие данные, и вообще, хорошо защищено, это не означает что в один прекрасный момент не
найдется уязвимость в вашей ОС или Web-сервере.

6. Незащищенность критичных данных (Sensitive Data Exposure)

Самый простой пример – передача данных по протоколу HTTP. Дело в том, что данные передаваемые 
по протоколу HTTP никак не шифруются, а при прохождении данных от компьютера пользователя до 
Web-сервера, данные пройдут достаточно много различных узлов: маршрутизатор офиса или домашний 
роутер, маршрутизатор провайдера, маршрутизатор на канале, маршрутизатор в дата-центре 
хостинг-провайдера сервера и так далее. На каждом из этих узлов может затаиться зловред, 
так называемый сниффер, программа, которая считывает весь трафик и передает злоумышленнику. 
А последний просматривает полученные данные на предмет персональных данных и данных кредитных карт. 

Такие данные должны передаваться исключительно по протоколу HTTPS, о чем должна гласить 
соответствующая надпись в адресной строке браузера:
https://site.com

Другой пример – отсутствие шифрования критичных данных, таких как пароли или номера кредитных карт.
В случае, если данные зашифрованы, то даже в случае получения несанкционированного доступа на сервер,
злоумышленник не сможет украсть критичные данные.  К паролям, в частности, должна применяться
необратимая хеш-функция – расшифровать шифрограмму при этом не возможно и проверка пароля
происходит путем формирования шифрограммы введенного пароля и сравнения ее с имеющейся в базе.

7. Отсутствие функций контроля доступа (Missing Function Level Access Control)

Суть уязвимости, как следует из названия, заключается в отсутствии проверки наличия надлежащего 
доступа к запрашиваемому объекту. 

Большинство веб-приложений проверяют права доступа, прежде чем отобразить данные в пользовательском 
интерфейсе. Тем не менее, приложения должны выполнять те же проверки контроля доступа на сервере при 
запросе любой функции. Ведь есть еще множество вспомогательных служебных запросов, которые, зачастую 
отправляются в фоновом режиме асинхронно, при помощи технологии AJAX. 

Если параметры запроса не достаточно тщательно проверяются, злоумышленники смогут подделать запрос 
для доступа к данным без надлежащего разрешения.

Частный, и пожалуй, самый распространенный случай данной уязвимости мы уже рассмотрели в 4 пункте 
нашей статьи – отсутствие проверки пользователя в личных сообщениях. 

8.  Межсайтовая подделка запроса (Cross-Site Request Forgery, CSRF/XSRF)

Вектор атаки CSRF, также известный как XSRF, позволяет злоумышленнику выполнять от имени жертвы 
действия на сервере, где не реализованы дополнительные проверки. 

Например, в некоторой платежной системе для перевода средств на другой аккаунт, есть страница вида:

demobank.com/transfer_money.jsp?transfer_amount=1000&transfer_account=123456789

где transfer_amount – сумма для перевода и transfer_account – номер аккаунта, 
куда должны быть переведены средства.

Если жертва заходит на сайт, созданный злоумышленником, от её лица тайно отправляется запрос
на вышеуказанную страницу платежной системы. Как результат – деньги уйдут на счет злоумышленника, 
после чего, вероятно, будут оперативно обменяны на Bitcoin или переведены в другую безвозвратную 
платежную систему, и получить их назад уже не получится.


9. Использование компонентов с известными уязвимостями 

Зачастую web-приложения написаны с использованием специальных библиотек или «фреймворков»
(англ – framework), которые поставляются сторонними компаниями. В большинстве случаев эти
компоненты имеют открытый исходный код, а это означает, что они есть не только у вас, но и
у миллионов людей во всем мире, которые штудируют их исходный код, в том числе, и на предмет
уязвимостей. И нужно отметить, что делают они это отнюдь не безуспешно.

Также уязвимости ищут (и находят) в более низкоуровневых компонентах системы, таких как сервер
базы данных, web-сервер, и наконец, компоненты операционной системы вплоть до ее ядра.

10. Непроверенные переадресации и пересылки

Web-приложения зачастую переадресуют пользователя с одной страницы на другую. В процессе
могут использоваться ненадлежащим образом проверяемые параметры с указанием страницы конечного
назначения переадресации. 

Без соответствующих проверок, атакующий может использовать такие страницы для переадресации
жертвы на подложный сайт, который, к примеру, может иметь очень схожий или неотличимый интерфейс,
но украдет ваши данные кредитной карты или другие критичные конфиденциальные данные.

```