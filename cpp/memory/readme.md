<h3>Оглавление</h3>
<a href="#one">1. Решение задачи</a><br>
<a href="#two">&nbsp;&nbsp;&nbsp;1.1. Пример работы</a><br>
<a href="#three">2. Теория</a><br>
<a href="#four">&nbsp;&nbsp;&nbsp;2.1. new (C++)</a><br>
<a href="#five">&nbsp;&nbsp;&nbsp;2.2. Перегрузка операторов new и delete для отдельных классов</a><br>
<a href="#six">&nbsp;&nbsp;&nbsp;2.3. Дополнительная литература</a><br>

<h3 id="one">Написать библиотеку для работы с памятью</h3>
<p></p>

<b id="two">1.1. Пример работы</b> <br>
<img src="https://habrastorage.org/files/020/458/7f1/0204587f1f5a41c29a24fedf16d020b1.png"/>
<p></p>

<h3 id="three">2. Теория</h3>
<b id="four">2.1. new (C++)</b>
<p>new — оператор языка программирования C++, обеспечивающий выделение динамической памяти в free store. За исключением формы, называемой «размещающей формой new», new пытается выделить достаточно памяти в куче для размещения новых данных и, в случае успеха, возвращает адрес свежевыделенной памяти. Однако, если new не может выделить память в куче, то он передаст (throw) исключение типа std::bad_alloc. Это устраняет необходимость явной проверки результата выделения. После встречи компилятором ключевого слова new им генерируется вызов конструктора класса</p>

<b id="six">2.2. Перегрузка операторов new и delete для отдельных классов</b>
<p>Операторы new и delete можно перегрузить. Для этого есть несколько причин:</p>

* Можно увеличить производительность за счёт кеширования: при удалении объекта не освобождать память, 
а сохранять указатели на свободные блоки, используя их для вновь конструируемых объектов.
*	Можно выделять память сразу под несколько объектов.
*	Можно реализовать собственный "сборщик мусора" (garbage collector).
*	Можно вести лог выделения/освобождения памяти.


<b id="six">2.3. Дополнительная литература</b>
<p><a href="https://ru.wikipedia.org/wiki/New_(C%2B%2B)">new (C++)</a></p>
<p><a href="http://stackoverflow.com/questions/184537/in-what-cases-do-i-use-malloc-vs-new">malloc vs new</a></p>