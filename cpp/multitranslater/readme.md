<h3>Оглавление</h3>
<a href="#one">1. Постановка задачи</a><br>
<a href="#two">&nbsp;&nbsp;&nbsp;1.1. Пример работы</a><br>
<a href="#three">2. Теория</a><br>
<a href="#four">&nbsp;&nbsp;&nbsp;2.1. Этапы трансляции с учѐтом промежуточного представления</a><br>
<a href="#five">&nbsp;&nbsp;&nbsp;2.2. Семантический анализ</a><br>
<a href="#six">&nbsp;&nbsp;&nbsp;2.3. Промежуточный код. Его цель</a><br>
<a href="#seven">&nbsp;&nbsp;&nbsp;2.4. Многоязыковые трансляторы</a><br>
<a href="#eight">&nbsp;&nbsp;&nbsp;2.5. Многоязыковые трансляторы. Переносимость</a><br>
<a href="#night">&nbsp;&nbsp;&nbsp;2.6. Виды промежуточных представлений </a><br>


<h3 id="one">1. Реализовать переводчик для двух исходных языков</h3>
<p>Реализовать переводчик для двух исходных языков – латыни и английского 
языка, целевой – русский (набор языков опционален - на ваш выбор). В данной работе использовать концепцию промежуточного языка.
</p>

<b id="two">1.1. Пример работы</b> <br>
<img src="https://habrastorage.org/files/d5a/e6e/386/d5ae6e386ecd460482039cca6ddcb76d.png"/>
<p></p>

<h3 id="three">2. Теория</h3>
<b id="four">2.1. Этапы трансляции с учѐтом промежуточного представления</b><br>
В процессе трансляции компилятор часто используют промежуточное представление (ПП) исходной программы, предназначенное прежде всего для удобства генерации кода и/или проведения различных оптимизаций. Сама форма ПП зависит от целей его использования.

Этапы работы интерпретатора:
*	лексический анализ;
*	синтаксический анализ;
*	семантический анализ;
*	создание промежуточного представления кода (при чистой интерпретации не выполняется);
*	исполнение.


<br>
<b id="five">2.2. Семантический анализ (СА)</b> <br>
Существенно отличается от лексического и синтаксического. Лексический и синтаксический анализ имеют дело со структурными, т.е. внешними, текстовыми конструкциями языка. Семантика же, ориентированная на содержательную интерпретацию, имеет дело с внутренним представлением «смысла» объектов, описанных в программе. 

СА можно сравнить с простым видом нейросети, состоящей из трех слоев: первый слой содержит множество слов (термов), второй – некое множество документов, соответствующих определенным ситуациям, а третий, средний, скрытый слой представляет собой множество узлов с различными весовыми коэффициентами, связывающих первый и второй слои.

Существуют три основных разновидности решения задачи методом СА:
* сравнение двух термов между собой
* сравнение двух документов между собой
* сравнение терма и документа

Недостатки:
*	Вероятностная модель метода не соответствует реальности
*	Существенным недостатком метода является значительное снижение скорости вычисления при увеличении объема входных данных 

<br>
<b id="six">2.3. Промежуточный код. Его цель</b> <br>
В качестве  промежуточных представлений  весьма распространены
линеаризованные представления.  Линеаризованное  представление
позволяет    относительно    легко    хранить    промежуточное
представление на  внешней памяти  и обрабатывать его в порядке
чтения.   Самая    распространенная   форма   линеаризованного
представления -  это запись  дерева либо  в порядке его обхода
снизу-вверх (постфиксная  запись, или обратной польской), либо
в порядке  обхода  его  сверху-вниз  (префиксная  запись,  или
прямой польской).

<br>
<b id="seven">2.4. Многоязыковые трансляторы. Засчѐт чего осуществляется добавление в транслятор исходного языка?
</b><br>
Это программа, предназначенная для осуществления программного перевода на любые другие языки

<br>
<b id="eight">2.5. Многоязыковые трансляторы. Засчѐт чего осуществляется перенос на другую платформу?</b><br>
~

<b id="night">2.6. Виды промежуточных представлений</b><br>
Наиболее часто используемыми формами ПП является ориентированный граф (в частности, абстрактное синтаксическое дерево, в том числе атрибутированное), трехадресный код (в виде троек или четверок), префиксная и постфиксная запись.

<b>Представление в виде ориентированного графа:</b> <br><br>
<img src="http://citforum.ru/programming/theory/serebryakov/main104x.gif" alt="">
<img src="http://citforum.ru/programming/theory/serebryakov/main105x.gif" alt="">

<b>Трехадресный код</b><br><br>
<img src="http://citforum.ru/programming/theory/serebryakov/8_4.png" alt="">

<b>Линеаризованные представления</b><br>
~ <br>

<b>Атрибутное дерево разбора</b><br>
<img src="https://habrastorage.org/files/d20/776/f49/d20776f49b7044c0805b012be5f270e7.png" alt="" align="left">
Атрибутное дерево разбора является, наверное, самой распространенной формой
организации внутренного представления программы. При таком подходе каждая
исходная конструкция языка представляется в виде узла дерева, содержащего ссылки на
все возможные элементы этой конструкции (естественно, каждый отдельный элемент
тоже может иметь сложную структуру и, таким образом, также может быть поддеревом).
Кроме того, каждый узел дерева может нагружаться дополнительными атрибутами,
такими, как ссылки в таблицы представлений или таблицы идентификаторов. В итоге,
вся программа представляется в виде единого дерева разбора. 

<b>Польская запись</b><br>
~ <br>

<b>Триады и тетрады</b><br>
<img src="https://habrastorage.org/files/84d/513/7f3/84d5137f3bf84330b0081e97fc50ec22.png" alt="" align="left">Тетрады (также называемые "четверками" или трехадресным кодом) состоят из двух
операндов, разделенных операцией, и результата операции, записываемого с помощью
равенства и обозначаемого целым числом (см. пример на слайде). Это целое число
является номером временной переменной, в которую записывается результат операции.
Таким образом, тетрады содержат явную ссылку на результат операции. В каком-то
смысле, это может считаться недостатком тетрад, так как при прямолинейной генерации
кода приходится порождать по одной временной переменной на каждую операцию в
программе.

Триады (также называемые "тройками" или двухадресным кодом) построены
аналогичным образом, но не содержат явного указания на результат операции, хотя на
эти результаты по-прежнему можно ссылаться в последующих командах.
Подразумевается, что задачу отслеживания и нумерации всех триад выполняет сам
компилятор. Понятно, что триады компактнее тетрад, но с другой стороны, отсутствие
явного указания на результат операции может затруднить фазу оптимизации. Эту
проблему можно решить путем использования косвенных триад, в которых вместо
ссылки на ранее использовавшуюся триаду используется ссылка на элемент специальной
таблицы указателей на триады. 